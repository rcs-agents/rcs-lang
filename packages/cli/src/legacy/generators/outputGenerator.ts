import fs from 'fs-extra';
import type { CompileOptions, CompiledOutput } from '../compiler';

export class OutputGenerator {
  async generate(
    output: CompiledOutput,
    outputPath: string,
    options: CompileOptions,
  ): Promise<void> {
    if (options.format === 'js') {
      await this.generateJavaScript(output, outputPath, options);
    } else {
      await this.generateJSON(output, outputPath, options);
    }
  }

  private async generateJavaScript(
    output: CompiledOutput,
    outputPath: string,
    _options: CompileOptions,
  ): Promise<void> {
    const jsContent = this.buildJavaScriptContent(output);
    await fs.writeFile(outputPath, jsContent, 'utf-8');
  }

  private async generateJSON(
    output: CompiledOutput,
    outputPath: string,
    options: CompileOptions,
  ): Promise<void> {
    const jsonContent = options.pretty ? JSON.stringify(output, null, 2) : JSON.stringify(output);

    await fs.writeFile(outputPath, jsonContent, 'utf-8');
  }

  private buildJavaScriptContent(output: CompiledOutput): string {
    const messagesJson = JSON.stringify(output.messages, null, 2);
    const flowsJson = JSON.stringify(output.flows, null, 2);
    const agentJson = JSON.stringify(output.agent, null, 2);

    return `// Generated by RCL Compiler
// This file contains the compiled output from your RCL agent definition

/**
 * Messages dictionary - Maps message IDs to normalized AgentMessage objects
 * Each message follows the schema defined in @schemas/agent-message.schema.json
 */
export const messages = ${messagesJson};

/**
 * Flow configurations - XState machine definitions for each flow
 * Each flow can be used to create XState machines for conversation logic
 */
export const flows = ${flowsJson};

/**
 * Agent configuration - Contains agent properties, config, and defaults
 * Includes display name, branding, contact info, and default settings
 */
export const agent = ${agentJson};

/**
 * Utility functions for working with the compiled agent
 */

/**
 * Get a message by ID
 * @param {string} messageId - The message ID
 * @returns {object|null} - The normalized message object or null if not found
 */
export function getMessage(messageId) {
  return messages[messageId] || undefined;
}

/**
 * Get a flow configuration by ID
 * @param {string} flowId - The flow ID
 * @returns {object|null} - The XState configuration or null if not found
 */
export function getFlow(flowId) {
  return flows[flowId] || undefined;
}

/**
 * Create XState machine from flow configuration
 * @param {string} flowId - The flow ID
 * @param {object} [options] - Additional XState machine options
 * @returns {object|null} - XState machine configuration
 */
export function createMachine(flowId, options = {}) {
  const flowConfig = getFlow(flowId);
  if (!flowConfig) {
    return null;
  }

  return {
    ...flowConfig,
    ...options
  };
}

/**
 * Generate postback data for suggestions
 * @param {string} action - The action type
 * @param {object} data - Additional data to include
 * @returns {string} - JSON string suitable for postbackData field
 */
export function generatePostbackData(action, data = {}) {
  const postbackData = {
    action,
    timestamp: Date.now(),
    ...data
  };
  
  const jsonString = JSON.stringify(postbackData);
  // Ensure it doesn't exceed 2048 character limit
  return jsonString.length > 2048 ? jsonString.substring(0, 2048) : jsonString;
}

/**
 * Validate message against schema constraints
 * @param {object} message - The message object to validate
 * @returns {object} - Validation result with valid boolean and errors array
 */
export function validateMessage(message) {
  const errors = [];
  
  // Check required fields
  if (!message.contentMessage) {
    errors.push('contentMessage is required');
  }
  
  if (!message.messageTrafficType) {
    errors.push('messageTrafficType is required');
  }
  
  // Check text length if present
  if (message.contentMessage?.text && message.contentMessage.text.length > 2048) {
    errors.push('text cannot exceed 2048 characters');
  }
  
  // Check suggestions count
  if (message.contentMessage?.suggestions && message.contentMessage.suggestions.length > 11) {
    errors.push('suggestions cannot exceed 11 items');
  }
  
  // Check suggestion text lengths
  if (message.contentMessage?.suggestions) {
    message.contentMessage.suggestions.forEach((suggestion, index) => {
      if (suggestion.reply?.text && suggestion.reply.text.length > 25) {
        errors.push(\`suggestion[\${index}].reply.text cannot exceed 25 characters\`);
      }
      if (suggestion.action?.text && suggestion.action.text.length > 25) {
        errors.push(\`suggestion[\${index}].action.text cannot exceed 25 characters\`);
      }
    });
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Get all message IDs
 * @returns {string[]} - Array of message IDs
 */
export function getMessageIds() {
  return Object.keys(messages);
}

/**
 * Get all flow IDs  
 * @returns {string[]} - Array of flow IDs
 */
export function getFlowIds() {
  return Object.keys(flows);
}

/**
 * Get agent display name
 * @returns {string} - The agent's display name
 */
export function getAgentDisplayName() {
  return agent.displayName || agent.name || 'Unknown Agent';
}

// Default export containing all exports
export default {
  messages,
  flows,
  agent,
  getMessage,
  getFlow,
  createMachine,
  generatePostbackData,
  validateMessage,
  getMessageIds,
  getFlowIds,
  getAgentDisplayName
};
`;
  }
}
