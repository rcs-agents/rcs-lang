import { beforeEach, describe, expect, test } from 'bun:test';
import fs from 'node:fs';
import path from 'node:path';
import { FlowCompiler } from '../src/legacy/compilers/flowCompiler';
import { AgentExtractor } from '../src/legacy/extractors/agentExtractor';
import { MessageNormalizer } from '../src/legacy/normalizers/messageNormalizer';

// Note: This test file uses mock AST structures instead of real parser
// No conditional import needed as it doesn't directly use tree-sitter

describe('End-to-End CLI Integration', () => {
  let messageNormalizer: MessageNormalizer;
  let agentExtractor: AgentExtractor;
  let flowCompiler: FlowCompiler;

  beforeEach(() => {
    messageNormalizer = new MessageNormalizer();
    agentExtractor = new AgentExtractor();
    flowCompiler = new FlowCompiler();
  });

  // Mock AST structure that simulates parsed realistic.rcl
  const createRealisticMockAST = () => ({
    type: 'source_file',
    children: [
      // Agent definition
      {
        type: 'agent_definition',
        children: [
          { type: 'identifier', text: 'agent' },
          { type: 'identifier', text: 'BMWCircularWorldAgent' },
          { type: 'property', text: 'displayName: "BMW Circular World"' },
          {
            type: 'config_section',
            children: [
              {
                type: 'config_property',
                text: 'description: "Explore BMW journey towards a circular world"',
              },
              { type: 'config_property', text: 'logoUri: "https://bmw.com/logo.png"' },
              { type: 'config_property', text: 'agentUseCase: "PROMOTIONAL"' },
            ],
          },
        ],
      },
      // Messages
      {
        type: 'text_shortcut',
        children: [
          { type: 'identifier', text: 'text' },
          { type: 'identifier', text: 'MsgWelcome' },
          {
            type: 'string',
            text: '"Welcome to BMW Circular World! 🌍 Discover how we are building a sustainable future."',
          },
          {
            type: 'suggestions',
            children: [
              {
                type: 'suggestion',
                children: [
                  {
                    type: 'reply',
                    children: [
                      {
                        type: 'text_property',
                        children: [{ type: 'string', text: '"Circular World"' }],
                      },
                      {
                        type: 'postback_data_property',
                        children: [{ type: 'string', text: '"circular_world"' }],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      {
        type: 'agent_message',
        children: [
          { type: 'identifier', text: 'agentMessage' },
          { type: 'identifier', text: 'MsgCircularWorld' },
          {
            type: 'content_message',
            children: [
              {
                type: 'rich_card',
                children: [
                  {
                    type: 'standalone_card',
                    children: [
                      {
                        type: 'card_orientation_property',
                        children: [{ type: 'atom', text: ':VERTICAL' }],
                      },
                      {
                        type: 'card_content',
                        children: [
                          {
                            type: 'title_property',
                            children: [{ type: 'string', text: '"Our Circular Journey"' }],
                          },
                          {
                            type: 'description_property',
                            children: [
                              {
                                type: 'string',
                                text: '"Learn about our sustainability initiatives"',
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      // Flows
      {
        type: 'flow_section',
        children: [
          { type: 'identifier', text: 'flow' },
          { type: 'identifier', text: 'MainFlow' },
          {
            type: 'flow_rule',
            children: [
              {
                type: 'flow_operand_or_expression',
                children: [{ type: 'identifier', text: ':start' }],
              },
              {
                type: 'flow_operand_or_expression',
                children: [{ type: 'identifier', text: 'MsgWelcome' }],
              },
            ],
          },
          {
            type: 'flow_rule',
            children: [
              {
                type: 'flow_operand_or_expression',
                children: [{ type: 'identifier', text: 'MsgWelcome' }],
              },
              {
                type: 'flow_operand_or_expression',
                children: [{ type: 'string', text: '"circular_world"' }],
              },
              {
                type: 'flow_operand_or_expression',
                children: [{ type: 'identifier', text: 'MsgCircularWorld' }],
              },
            ],
          },
        ],
      },
    ],
  });

  describe('Complete Compilation Pipeline', () => {
    test('should compile a complete RCL agent with messages and flows', () => {
      const mockAST = createRealisticMockAST() as any;

      // Step 1: Extract agent configuration
      const agentConfig = agentExtractor.extractAgentConfig(mockAST);
      expect(agentConfig).toBeDefined();
      expect(agentConfig?.name).toBe('BMWCircularWorldAgent');
      expect(agentConfig?.displayName).toBe('BMW Circular World');

      // Step 2: Extract and normalize messages
      const messages = messageNormalizer.extractAndNormalize(mockAST);
      expect(messages).toBeDefined();
      expect(messages.MsgWelcome).toBeDefined();
      expect(messages.MsgCircularWorld).toBeDefined();

      // Verify message content
      expect(messages.MsgWelcome.contentMessage.text).toContain('Welcome to BMW');
      expect(messages.MsgWelcome.contentMessage.suggestions).toBeDefined();
      expect(messages.MsgWelcome.contentMessage.suggestions).toHaveLength(1);

      // Verify rich card message
      expect(messages.MsgCircularWorld.contentMessage.richCard).toBeDefined();
      expect(messages.MsgCircularWorld.contentMessage.richCard?.standaloneCard).toBeDefined();

      // Step 3: Compile flows
      const flows = flowCompiler.compileFlows(mockAST);
      expect(flows).toBeDefined();
      expect(flows.MainFlow).toBeDefined();
      expect(flows.MainFlow.id).toBe('MainFlow');
      expect(flows.MainFlow.initial).toBe('start');

      // Step 4: Verify end-to-end consistency
      // Messages referenced in flows should exist
      const flowStates = Object.keys(flows.MainFlow.states);
      expect(flowStates).toContain('MsgWelcome');
      expect(flowStates).toContain('MsgCircularWorld');

      // Agent should reference these messages
      expect(agentConfig?.messages).toContain('MsgWelcome');
      expect(agentConfig?.messages).toContain('MsgCircularWorld');

      // console.log('Compilation Results:');
      // console.log('Agent Config:', JSON.stringify(agentConfig, null, 2));
      // console.log('Messages:', Object.keys(messages));
      // console.log('Flows:', Object.keys(flows));
    });

    test('should handle schema validation throughout compilation', () => {
      const mockAST = createRealisticMockAST() as any;

      // Extract everything
      const agentConfig = agentExtractor.extractAgentConfig(mockAST);
      const messages = messageNormalizer.extractAndNormalize(mockAST);
      const flows = flowCompiler.compileFlows(mockAST);

      // All extractions should succeed without throwing
      expect(agentConfig).toBeDefined();
      expect(messages).toBeDefined();
      expect(flows).toBeDefined();

      // Messages should have valid structure
      Object.values(messages).forEach((message) => {
        expect(message).toHaveProperty('contentMessage');
        expect(message).toHaveProperty('messageTrafficType');
      });

      // Flows should have valid XState structure
      Object.values(flows).forEach((flow) => {
        expect(flow).toHaveProperty('id');
        expect(flow).toHaveProperty('initial');
        expect(flow).toHaveProperty('states');
        expect(flow).toHaveProperty('context');
      });
    });

    test('should create coherent conversation flow', () => {
      const mockAST = createRealisticMockAST() as any;

      const messages = messageNormalizer.extractAndNormalize(mockAST);
      const flows = flowCompiler.compileFlows(mockAST);

      // Get the main flow
      const mainFlow = flows.MainFlow;
      expect(mainFlow).toBeDefined();

      // Trace the conversation path
      expect(mainFlow.initial).toBe('start');
      expect(mainFlow.states.start).toBeDefined();

      // Should transition from start to MsgWelcome
      expect(mainFlow.states).toHaveProperty('MsgWelcome');

      // MsgWelcome should have suggestions matching flow transitions
      const welcomeMsg = messages.MsgWelcome;
      expect(welcomeMsg.contentMessage.suggestions).toBeDefined();

      const suggestionPostback = welcomeMsg.contentMessage.suggestions?.[0].reply?.postbackData;
      expect(suggestionPostback).toBe('circular_world');

      // Flow should handle this postback event
      expect(mainFlow.states.MsgWelcome.on).toBeDefined();
      expect(mainFlow.states).toHaveProperty('MsgCircularWorld');
    });
  });

  describe('Real File Processing', () => {
    test('should handle realistic.rcl file structure if available', () => {
      const realisticPath = path.join(__dirname, '../../../examples/realistic-fixed.rcl');

      if (fs.existsSync(realisticPath)) {
        const content = fs.readFileSync(realisticPath, 'utf8');
        expect(content).toBeDefined();
        expect(content.length).toBeGreaterThan(0);

        // File should contain expected RCL constructs
        expect(content).toMatch(/agent\s+\w+/);
        expect(content).toMatch(/displayName:/);
        expect(content).toMatch(/flow\s+\w+/);
        expect(content).toMatch(/text\s+\w+/);
        // No agentMessage in new syntax, messages are in messages section

        console.log('Realistic.rcl file found and validated');
        console.log('File size:', content.length, 'characters');
        console.log('Contains agent definitions:', !!content.match(/agent\s+\w+/));
        console.log('Contains flow definitions:', !!content.match(/flow\s+\w+/g)?.length);
        console.log(
          'Contains message definitions:',
          !!content.match(/(text|agentMessage)\s+\w+/g)?.length,
        );
      } else {
        console.log('realistic-fixed.rcl not found, skipping file-based test');
        expect(true).toBe(true); // Skip test gracefully
      }
    });

    test('should process realistic.rcl with mock parser if available', () => {
      // This would be the integration test with actual parser
      // For now, we simulate the expected structure

      const expectedAgentConfig = {
        name: 'BMWCircularWorldAgent',
        displayName: 'BMW Circular World',
        rcsBusinessMessagingAgent: {
          description: expect.any(String),
          agentUseCase: 'PROMOTIONAL',
        },
        flows: expect.arrayContaining(['MainFlow', 'CircularWorldFlow']),
        messages: expect.any(Array),
      };

      const expectedMessageTypes = [
        'MsgWelcome',
        'MsgCircularWorld',
        'MsgCircularWorldAim',
        'MsgCircularWorldPresent',
      ];

      const expectedFlowTypes = [
        'MainFlow',
        'CircularWorldFlow',
        'CircularWorldAimFlow',
        'CircularWorldPresentFlow',
      ];

      // Simulate successful compilation
      expect(expectedAgentConfig.name).toBe('BMWCircularWorldAgent');
      expect(expectedMessageTypes).toContain('MsgWelcome');
      expect(expectedFlowTypes).toContain('MainFlow');

      console.log('Expected compilation output structure validated');
    });
  });

  describe('Error Handling and Edge Cases', () => {
    test('should handle incomplete RCL files gracefully', () => {
      const incompleteAST = {
        type: 'source_file',
        children: [
          {
            type: 'agent_definition',
            children: [
              { type: 'identifier', text: 'agent' },
              { type: 'identifier', text: 'IncompleteAgent' },
              // Missing displayName and other required fields
            ],
          },
        ],
      } as any;

      // Should not throw errors
      expect(() => {
        const agentConfig = agentExtractor.extractAgentConfig(incompleteAST);
        const messages = messageNormalizer.extractAndNormalize(incompleteAST);
        const flows = flowCompiler.compileFlows(incompleteAST);

        expect(agentConfig).toBeDefined();
        expect(messages).toBeDefined();
        expect(flows).toBeDefined();
      }).not.toThrow();
    });

    test('should handle RCL with only messages (no flows)', () => {
      const messagesOnlyAST = {
        type: 'source_file',
        children: [
          {
            type: 'agent_definition',
            children: [
              { type: 'identifier', text: 'agent' },
              { type: 'identifier', text: 'MessagesOnlyAgent' },
              { type: 'property', text: 'displayName: "Messages Only"' },
            ],
          },
          {
            type: 'text_shortcut',
            children: [
              { type: 'identifier', text: 'text' },
              { type: 'identifier', text: 'OnlyMessage' },
              { type: 'string', text: '"This is the only message"' },
            ],
          },
        ],
      } as any;

      const agentConfig = agentExtractor.extractAgentConfig(messagesOnlyAST);
      const messages = messageNormalizer.extractAndNormalize(messagesOnlyAST);
      const flows = flowCompiler.compileFlows(messagesOnlyAST);

      expect(agentConfig?.name).toBe('MessagesOnlyAgent');
      expect(messages.OnlyMessage).toBeDefined();
      expect(Object.keys(flows)).toHaveLength(0); // No flows
    });

    test('should handle RCL with only flows (no messages)', () => {
      const flowsOnlyAST = {
        type: 'source_file',
        children: [
          {
            type: 'agent_definition',
            children: [
              { type: 'identifier', text: 'agent' },
              { type: 'identifier', text: 'FlowsOnlyAgent' },
              { type: 'property', text: 'displayName: "Flows Only"' },
            ],
          },
          {
            type: 'flow_section',
            children: [
              { type: 'identifier', text: 'flow' },
              { type: 'identifier', text: 'OnlyFlow' },
              {
                type: 'flow_rule',
                children: [
                  {
                    type: 'flow_operand_or_expression',
                    children: [{ type: 'identifier', text: ':start' }],
                  },
                  {
                    type: 'flow_operand_or_expression',
                    children: [{ type: 'identifier', text: 'SomeState' }],
                  },
                ],
              },
            ],
          },
        ],
      } as any;

      const agentConfig = agentExtractor.extractAgentConfig(flowsOnlyAST);
      const messages = messageNormalizer.extractAndNormalize(flowsOnlyAST);
      const flows = flowCompiler.compileFlows(flowsOnlyAST);

      expect(agentConfig?.name).toBe('FlowsOnlyAgent');
      expect(Object.keys(messages)).toHaveLength(0); // No messages
      expect(flows.OnlyFlow).toBeDefined();
    });
  });

  describe('Performance and Scalability', () => {
    test('should handle large RCL files efficiently', () => {
      // Create a large mock AST with many components
      const largeAST: any = {
        type: 'source_file',
        children: [
          {
            type: 'agent_definition',
            children: [
              { type: 'identifier', text: 'agent' },
              { type: 'identifier', text: 'LargeAgent' },
              { type: 'property', text: 'displayName: "Large Test Agent"' },
            ],
          },
        ],
      };

      // Add many messages
      for (let i = 0; i < 100; i++) {
        largeAST.children.push({
          type: 'text_shortcut',
          children: [
            { type: 'identifier', text: 'text' },
            { type: 'identifier', text: `Msg${i}` },
            { type: 'string', text: `"Message ${i} content"` },
          ],
        });
      }

      // Add many flows
      for (let i = 0; i < 20; i++) {
        largeAST.children.push({
          type: 'flow_section',
          children: [
            { type: 'identifier', text: 'flow' },
            { type: 'identifier', text: `Flow${i}` },
            {
              type: 'flow_rule',
              children: [
                {
                  type: 'flow_operand_or_expression',
                  children: [{ type: 'identifier', text: ':start' }],
                },
                {
                  type: 'flow_operand_or_expression',
                  children: [{ type: 'identifier', text: `Msg${i}` }],
                },
              ],
            },
          ],
        });
      }

      const startTime = Date.now();

      const agentConfig = agentExtractor.extractAgentConfig(largeAST);
      const messages = messageNormalizer.extractAndNormalize(largeAST);
      const flows = flowCompiler.compileFlows(largeAST);

      const endTime = Date.now();
      const compilationTime = endTime - startTime;

      // Should complete in reasonable time (< 1000ms for 100 messages + 20 flows)
      expect(compilationTime).toBeLessThan(1000);

      // Should extract all components correctly
      expect(Object.keys(messages)).toHaveLength(100);
      expect(Object.keys(flows)).toHaveLength(20);
      expect(agentConfig?.messages).toHaveLength(100);

      // console.log(`Compiled 100 messages and 20 flows in ${compilationTime}ms`);
    });
  });

  describe('Output Validation', () => {
    test('should produce JSON-serializable output', () => {
      const mockAST = createRealisticMockAST() as any;

      const agentConfig = agentExtractor.extractAgentConfig(mockAST);
      const messages = messageNormalizer.extractAndNormalize(mockAST);
      const flows = flowCompiler.compileFlows(mockAST);

      // All outputs should be JSON serializable
      expect(() => JSON.stringify(agentConfig)).not.toThrow();
      expect(() => JSON.stringify(messages)).not.toThrow();
      expect(() => JSON.stringify(flows)).not.toThrow();

      // Serialized output should be reasonable size
      const agentJSON = JSON.stringify(agentConfig);
      const messagesJSON = JSON.stringify(messages);
      const flowsJSON = JSON.stringify(flows);

      expect(agentJSON.length).toBeGreaterThan(50);
      expect(messagesJSON.length).toBeGreaterThan(100);
      expect(flowsJSON.length).toBeGreaterThan(100);
    });

    test('should create valid compilation manifest', () => {
      const mockAST = createRealisticMockAST() as any;

      const agentConfig = agentExtractor.extractAgentConfig(mockAST);
      const messages = messageNormalizer.extractAndNormalize(mockAST);
      const flows = flowCompiler.compileFlows(mockAST);

      // Create a compilation manifest
      const manifest = {
        agent: agentConfig,
        messages: messages,
        flows: flows,
        metadata: {
          compiledAt: new Date().toISOString(),
          messageCount: Object.keys(messages).length,
          flowCount: Object.keys(flows).length,
          version: '1.0.0',
        },
      };

      expect(manifest.agent).toBeDefined();
      expect(manifest.messages).toBeDefined();
      expect(manifest.flows).toBeDefined();
      expect(manifest.metadata.messageCount).toBeGreaterThan(0);
      expect(manifest.metadata.flowCount).toBeGreaterThan(0);

      // Should be JSON serializable
      expect(() => JSON.stringify(manifest)).not.toThrow();

      // console.log('Compilation manifest created:', {
      //   agent: manifest.agent?.name,
      //   messageCount: manifest.metadata.messageCount,
      //   flowCount: manifest.metadata.flowCount,
      // });
    });
  });
});
