import * as fs from 'node:fs';
import * as path from 'node:path';
import { getOutputPath } from '../config/loader.js';
import type { RclConfig } from '../config/types.js';
import type { CompiledAgent, Diagnostic } from '../program/types.js';

/**
 * Emits compiled RCL output to files
 */
export class Emitter {
  private diagnostics: Diagnostic[] = [];

  constructor(private config: RclConfig) {}

  /**
   * Emit compiled agent to files
   */
  async emit(
    compiledAgent: CompiledAgent,
    sourceFile: string,
  ): Promise<{ emittedFiles: string[]; diagnostics: Diagnostic[] }> {
    this.diagnostics = [];
    const emittedFiles: string[] = [];

    try {
      // Determine output paths
      const baseName = path.basename(sourceFile, '.rcl');

      // Emit JSON if enabled
      if (this.config.compilerOptions?.emit?.json !== false) {
        const jsonPath = getOutputPath(sourceFile, this.config, '.json');
        await this.emitJSON(compiledAgent, jsonPath);
        emittedFiles.push(jsonPath);
      }

      // Emit JavaScript if enabled
      if (this.config.compilerOptions?.emit?.javascript !== false) {
        const jsPath = getOutputPath(sourceFile, this.config, '.js');
        await this.emitJavaScript(compiledAgent, jsPath, baseName);
        emittedFiles.push(jsPath);
      }

      // Emit TypeScript declarations if enabled
      if (this.config.compilerOptions?.emit?.declarations !== false) {
        const dtsPath = getOutputPath(sourceFile, this.config, '.d.ts');
        await this.emitDeclarations(compiledAgent, dtsPath, baseName);
        emittedFiles.push(dtsPath);
      }

      return { emittedFiles, diagnostics: this.diagnostics };
    } catch (error) {
      this.diagnostics.push({
        message: `Failed to emit files: ${error instanceof Error ? error.message : String(error)}`,
        severity: 'error',
        file: sourceFile,
      });
      return { emittedFiles, diagnostics: this.diagnostics };
    }
  }

  /**
   * Emit JSON file
   */
  private async emitJSON(agent: CompiledAgent, outputPath: string): Promise<void> {
    const dir = path.dirname(outputPath);
    await fs.promises.mkdir(dir, { recursive: true });

    const json = JSON.stringify(agent, null, 2);
    await fs.promises.writeFile(outputPath, json, 'utf-8');
  }

  /**
   * Emit JavaScript file
   */
  private async emitJavaScript(
    agent: CompiledAgent,
    outputPath: string,
    baseName: string,
  ): Promise<void> {
    const dir = path.dirname(outputPath);
    await fs.promises.mkdir(dir, { recursive: true });

    const jsonFileName = `${baseName}.json`;
    const isESM = this.config.compilerOptions?.module === 'esm';

    const js = isESM
      ? this.generateESMJavaScript(agent, jsonFileName)
      : this.generateCommonJSJavaScript(agent, jsonFileName);

    await fs.promises.writeFile(outputPath, js, 'utf-8');
  }

  /**
   * Generate ES Module JavaScript
   */
  private generateESMJavaScript(_agent: CompiledAgent, jsonFileName: string): string {
    return `// Generated by RCL Compiler
// This file contains the compiled output from your RCL agent definition

import agentData from './${jsonFileName}.js' assert { type: 'json' };

/**
 * Messages dictionary - Maps message IDs to normalized AgentMessage objects
 * Each message follows the schema defined in @schemas/agent-message.schema.json
 */
export const messages = agentData.messages;

/**
 * Flow configurations - XState machine definitions for each flow
 * Each flow can be used to create XState machines for conversation logic
 */
export const flows = agentData.flows;

/**
 * Agent configuration - Contains agent properties, config, and defaults
 * Includes display name, branding, contact info, and default settings
 */
export const agent = agentData.agent;

/**
 * Get a message by ID
 * @param {string} messageId - The message ID
 * @returns {object|null} - The normalized message object or null if not found
 */
export function getMessage(messageId) {
  return messages[messageId] || null;
}

/**
 * Get a flow configuration by ID
 * @param {string} flowId - The flow ID
 * @returns {object|null} - The XState configuration or null if not found
 */
export function getFlow(flowId) {
  return flows[flowId] || null;
}

/**
 * Create XState machine from flow configuration
 * @param {string} flowId - The flow ID
 * @param {object} options - Additional XState machine options
 * @returns {object|null} - XState machine configuration
 */
export function createMachine(flowId, options = {}) {
  const flowConfig = getFlow(flowId);
  if (!flowConfig) {
    return null;
  }

  return {
    ...flowConfig,
    ...options
  };
}

// Default export containing all exports
export default {
  messages,
  flows,
  agent,
  getMessage,
  getFlow,
  createMachine
};
`;
  }

  /**
   * Generate CommonJS JavaScript
   */
  private generateCommonJSJavaScript(_agent: CompiledAgent, jsonFileName: string): string {
    return `// Generated by RCL Compiler
// This file contains the compiled output from your RCL agent definition

const agentData = require('./${jsonFileName}');

/**
 * Messages dictionary - Maps message IDs to normalized AgentMessage objects
 * Each message follows the schema defined in @schemas/agent-message.schema.json
 */
const messages = agentData.messages;

/**
 * Flow configurations - XState machine definitions for each flow
 * Each flow can be used to create XState machines for conversation logic
 */
const flows = agentData.flows;

/**
 * Agent configuration - Contains agent properties, config, and defaults
 * Includes display name, branding, contact info, and default settings
 */
const agent = agentData.agent;

/**
 * Get a message by ID
 * @param {string} messageId - The message ID
 * @returns {object|null} - The normalized message object or null if not found
 */
function getMessage(messageId) {
  return messages[messageId] || null;
}

/**
 * Get a flow configuration by ID
 * @param {string} flowId - The flow ID
 * @returns {object|null} - The XState configuration or null if not found
 */
function getFlow(flowId) {
  return flows[flowId] || null;
}

/**
 * Create XState machine from flow configuration
 * @param {string} flowId - The flow ID
 * @param {object} options - Additional XState machine options
 * @returns {object|null} - XState machine configuration
 */
function createMachine(flowId, options = {}) {
  const flowConfig = getFlow(flowId);
  if (!flowConfig) {
    return null;
  }

  return {
    ...flowConfig,
    ...options
  };
}

module.exports = {
  messages,
  flows,
  agent,
  getMessage,
  getFlow,
  createMachine
};
`;
  }

  /**
   * Emit TypeScript declarations
   */
  private async emitDeclarations(
    _agent: CompiledAgent,
    outputPath: string,
    _baseName: string,
  ): Promise<void> {
    const dir = path.dirname(outputPath);
    await fs.promises.mkdir(dir, { recursive: true });

    const dts = `// Generated TypeScript declarations for RCL agent

export interface AgentMessage {
  contentMessage: {
    text?: string;
    richCard?: any;
    uploadedRbmFile?: any;
  };
  messageTrafficType: 'TRANSACTION' | 'PROMOTIONAL';
}

export interface FlowState {
  on: Record<string, string>;
  type?: 'final';
}

export interface Flow {
  id: string;
  initial: string;
  states: Record<string, FlowState>;
}

export interface Agent {
  name: string;
  displayName?: string;
  brandName?: string;
  config?: any;
  defaults?: any;
}

export declare const messages: Record<string, AgentMessage>;
export declare const flows: Record<string, Flow>;
export declare const agent: Agent;

export declare function getMessage(messageId: string): AgentMessage | null;
export declare function getFlow(flowId: string): Flow | null;
export declare function createMachine(flowId: string, options?: any): any;

declare const _default: {
  messages: typeof messages;
  flows: typeof flows;
  agent: typeof agent;
  getMessage: typeof getMessage;
  getFlow: typeof getFlow;
  createMachine: typeof createMachine;
};

export default _default;
`;

    await fs.promises.writeFile(outputPath, dts, 'utf-8');
  }
}
